<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project 3 Write-up</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/+esm" type="module"></script>
    <style>
    /* Base styling */
    html {
      color-scheme: light dark;
      background: Canvas;
      color: CanvasText;
    }

    body {
      font: 100%/1.6 system-ui, sans-serif;
      max-width: 80ch;
      margin: 2rem auto;
      padding: 0 1.5rem;
    }

    /* Page header */
    .page-header {
      font-size: 0.9rem;
      color: #666;
      margin-bottom: 2rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid #ddd;
    }

    /* Headings */
    h1 {
      font-size: 2rem;
      font-weight: 600;
      margin-bottom: 1rem;
      line-height: 1.25;
    }

    h2 {
      font-size: 1.4rem;
      margin-top: 2rem;
      margin-bottom: 0.75rem;
      border-left: 4px solid #ddd;
      padding-left: 0.6rem;
      font-weight: 600;
    }

    h3 {
      font-size: 1.15rem;
      margin-top: 1.5rem;
      margin-bottom: 0.4rem;
      font-weight: 600;
    }

    p {
      margin-bottom: 1rem;
    }

    /* Code formatting */
    pre {
      background: #f3f3f3;
      padding: 1rem;
      border-radius: 6px;
      overflow-x: auto;
      font-size: 0.9rem;
      line-height: 1.45;
      white-space: pre-wrap;
    }

    code {
      background: #f3f3f3;
      padding: 0.1rem 0.3rem;
      border-radius: 4px;
      font-size: 0.95rem;
    }

    /* Contributor block */
    .contributor {
      margin-bottom: 1.2rem;
    }

  </style>

</head>
<body>
    <!--Header/Title-->
    <div class="page-header">Project 3 · Team Smooth JAZ · 
      <a href="index.html" class="header-link">Visualization</a>
    </div>
    <h1>Project 3 Final Write-Up</h1>

  <h2>Rationale for Design Decisions</h2>

  <h3>Design Decision #1: Map</h3>
  <p>
    The core of the visualization is a map that translates the given precinct numbers into a geographic representation. The alternative was to simply group and report by precinct number using a bar chart. However, a map is the most effective visualization for this data because our claim is spatial. Precincts vary in size/shape and, without a map, it is not clear which precincts neighbor each other. It is also not clear which precincts belong to which New York City boroughs. The story we are trying to tell is related to spatial clustering and a map reveals that immediately and intuitively to readers.
  </p>

  <h3>Design Decision #2: Color Scale</h3>
  <p>
    An important design decision was to use a color scale to represent the number of complaints per precinct. The alternative was to print the numeric values in the map or use something like a bar chart to show count by bar height. However, the goal is to help readers immediately see where complaints are low/high and this is best accomplished by a color hue transitioning from a “neutral-feeling” pale yellow to a “severe-feeling” dark red as the count increases.The const colorScale defines the color that is used for the legend, and the argument of d3.scaleSequential(d3.interpolateYlOrRd) defines the legend that highlights the precincts in New York from least to greatest, with the smaller values highlighted in yellow and the larger values highlighted in red.
  </p>

<pre><code>const colorScale = d3.scaleSequential(d3.interpolateYlOrRd);</code></pre>

  <p>
    Another important design decision in this visualization was to apply a gray hue to all New York City precincts that had no complaints for an entire year. The motivation behind this decision was to quickly direct the reader’s attention to the precincts that did not have a complaint in a given year.The alternative was not to adjust the visual encoding at all, so that all precincts with zero total complaints display a light yellow shade similar to those with fewer than 50 complaints; however, this made the trends over time less clear.
  </p>

  <p>
    In the visualization.js code, the object of precinct paths was created to bin the polygons to the svg object. In the block of code for precinctPath.join, the attribute of stroke is defined and set to the rgb code of #444, which accounts for gray.
  </p>

  <h3>Design Decision #3: Brushing</h3>
  <p>
    Another critical decision was to implement the brushing technique in d3 to return the total number of complaints for the user-selected precincts. The output of this technique is a list of each selected precinct, along with a breakdown of complaints by precinct, and the percentage of total complaints that occurred in that precinct. Lastly, the total number of complaints is listed along with the rate of complaints accumulated in a given year. The alternative was to allow the user to hover over each precinct with their mouse, which would return the total number of complaints in that precinct for a selected year. However, we decided to implement brushing to return the aggregate totals for each precinct quickly.
  </p>

  <p>
    In the visualization.js code, the const infobox variable captures the selected precinct number and the total number of complaints. Additionally, the function brushes establishes the brushing behavior when the user selects multiple precincts at once and returns the elements captured in the infobox.
  </p>

<pre><code>// --- Create info box for brushing summary so that it is reusable and never duplicated---
const infoBox = d3.select("body").selectAll("#brush-info")
  .data([null])
  .join("div")
  .attr("id", "brush-info")
  .style("margin-top", "10px")
  .style("font-family", "sans-serif")
  .style("line-height", "1.4")
  .html("&lt;strong&gt;Selected precincts:&lt;/strong&gt; None&lt;br&gt;&lt;strong&gt;Total complaints:&lt;/strong&gt; 0");

  // --- Add brushing functionality ---
  const brush = d3.brush()
    .extent([[0, 0], [width, height]])
    .on("brush end", brushed);

  const brushGroup = svg.append("g")
    .attr("class", "brush")
    .call(brush);

  // --- Brushing behavior ---
  function brushed({ selection }) {
    if (!selection) {
      svg.selectAll(".precinct").classed("selected", false);
      infoBox.html("&lt;strong&gt;Selected precincts:&lt;/strong&gt; None&lt;br&gt;&lt;strong&gt;Total complaints:&lt;/strong&gt; 0");
      return;
    }

    const [[x0, y0], [x1, y1]] = selection;
    let totalComplaints = 0;
    const selectedPrecincts = [];
    const precinctBreakdown = [];

    const totalYearComplaints = d3.sum(
      svg.selectAll(".precinct").data(),
      d => d.properties.total_complaints
    );

    svg.selectAll(".precinct")
      .classed("selected", d => {
        const [cx, cy] = path.centroid(d);
        if (!cx || !cy) return false;
        const selected = cx >= x0 && cx <= x1 && cy >= y0 && cy <= y1;
        if (selected) {
          const precinct = d.properties.precinct;
          const complaints = d.properties.total_complaints;
          totalComplaints += complaints;
          precinctBreakdown.push({
            precinct,
            complaints,
            percent: totalYearComplaints > 0
              ? (complaints / totalYearComplaints) * 100
              : 0
          });
          selectedPrecincts.push(precinct);
        }
        return selected;
      });

    const breakdownText = precinctBreakdown.length
      ? precinctBreakdown
          .sort((a, b) => d3.ascending(+a.precinct, +b.precinct))
          .map(p =>
            `&nbsp;&nbsp;${p.precinct}: ${p.complaints} (${p.percent.toFixed(1)}%)`
          )
          .join("&lt;br&gt;")
      : "None";

    infoBox.html(`
      &lt;strong&gt;Selected precincts:&lt;/strong&gt; ${
        selectedPrecincts.length > 0 ? selectedPrecincts.join(", ") : "None"
      }&lt;br&gt;
      &lt;strong&gt;Complaints per precinct:&lt;/strong&gt;&lt;br&gt;
      ${breakdownText}&lt;br&gt;
      &lt;strong&gt;Total complaints:&lt;/strong&gt; ${totalComplaints.toLocaleString()}
      (${((totalComplaints / totalYearComplaints) * 100).toFixed(1)}% of year total)
    `);
  }

  // --- Keep brush totals in sync when year changes ---
  yearSlider.addEventListener("input", e => {
    updateHeatmap(+e.target.value);
    brushed({ selection: d3.brushSelection(svg.select(".brush").node()) });
  });
});
</code></pre>

  <h3>Design Decision #4: Slider</h3>
  <p>
    Another important design decision was to add a slider at the top of the screen to adjust the complaint year. The range of years in this slider spans from 1985 to 2019. The rationale for this decision was to allow the user to detect increases and decreases in complaints filed in New York City precincts over time. The constants of yearSlider and yearLabel (const yearSlider and const yearLabel) generate the slider mechanic as well as the years where the precinct complaint is documented. We did not consider any alternatives to the year-slider features, as we wanted the reader to see trends in complaints filed per precinct over time.
  </p>

<pre><code>// Select yearSlider & yearLabel html elements
const yearSlider = document.getElementById("yearSlider");
const yearLabel = document.getElementById("yearLabel");

// Determine year range dynamically
yearSlider.min = years[0];
yearSlider.max = years[years.length - 1];
yearSlider.value = years[0];
yearLabel.textContent = years[0];

// Initialize heatmap on page load
updateHeatmap(+yearSlider.value);

// Add eventListener to slider
yearSlider.addEventListener("input", e => {
  updateHeatmap(+e.target.value);
});

// Keep brush totals in sync when year changes
yearSlider.addEventListener("input", e => {
  updateHeatmap(+e.target.value);
  brushed({ selection: d3.brushSelection(svg.select(".brush").node()) });
});
</code></pre>

  <h2>Development Process</h2>

  <h3>General Comments</h3>
  <p>
    Our development process was almost entirely asynchronous and remote. We became a group through Piazza and immediately set-up a discord server to facilitate communication. We broke the “project brief” down into general tasks and communicated our status and progress with these tasks via discord. We heavily relied on collaborative tools, including: Google Docs for brainstorming and write-ups and GitHub for code development. We used the discord to bounce ideas and feedback off of each other. Finally, we all attended the live peer-review session and met virtually immediately afterwards in order to decide on the path forward for our final visualization. The aspects that took up the most time were the initial data explorations and the development of our claim.
  </p>

  <h3>Individual Member Contributions</h3>

  <div class="contributor">
    <span class="name">Alex contributed to this project by writing code to introduce the brushing feature to the visualization, along with aggregate totals for each precinct and the percentage of total precincts captured within each brush stroke. Additionally, Alex wrote code to grey out the precincts in New York City that had zero complaints in a given year. Additionally, Alex made a slight tweak to reduce the value of the const legendHeight to make the legend on the x-axis more visible. Cumulatively, Alex contributed 8 hours to this product.</span>
  </div>

  <div class="contributor">
    <span class="name">Jillian contributed to this project by acting as a project manager (turning in registration form, turning in project checkpoint, starting Github repo, keeping track of deliverables/deadlines). Jillian also authored the starting code of the project, including initial data transformation (counting and grouping of complaints) and initial heat map (grid of squares) that was submitted for the checkpoint. Jillian also helped develop a more clear “claim” as a result of feedback from the peer-review session. Finally, Jillian added final styling to the HTML and JS provided by the other team members. Cumulatively, Jillian contributed 15 hours to this project.</span>
  </div>

  <div class="contributor">
    <span class="name">Zack contributed to this project by proposing the idea for an interactive precinct based complaint heatmap. Zack filled in missing precinct–year combinations with zero complaint entries so that every precinct remained visible in every year. Also integrated the official NYC precinct GeoJSON, transforming the initial square-grid prototype into a map-based visualization. Zack improved the readability of the heatmap by adjusting the color scale and legend so earlier years with lower complaint counts still displayed clear visual contrast, and also wrote the project README. Cumulatively, Zack contributed approximately 14 hours to this project.</span>
  </div>

</body>
</html>
